# إصلاحات المشاكل الثلاثة في Pipeline رفع الفيديوهات

## 📅 تاريخ الإصلاح
تم إجراء هذه الإصلاحات بتاريخ اليوم لمعالجة ثلاثة مشاكل حرجة ظهرت في آخر كتاب تم رفعه (Emotional Intelligence لـ Daniel Goleman).

---

## ❌ المشاكل التي تم اكتشافها

### 1️⃣ **مشكلة التاغات (Tags)**

#### 🔴 **الوصف:**
التاغات التي تم رفعها للكتاب كانت محدودة جداً ولم تحتوي على تنوع كافٍ:
```
Daniel Goleman, Emotional skills, InkEcho, emotional regulation, empathy, 
human psychology, interpersonal relations, mental well-being, personal growth, 
self-awareness, social intelligence, success strategies, Emotional Intelligence Daniel Goleman
```

المشكلة: عدد قليل من التاغات (13 تاغ فقط)، بينما YouTube يسمح بما يصل إلى 500 حرف.

#### 🔍 **السبب الجذري:**
1. ملف `config/prompts.json` كان يطلب من Gemini فقط **10 تاغات**
2. الكود في `youtube_metadata.py` كان يحد النتيجة بـ **20 تاغاً** فقط
3. لم يكن هناك تنوع كافٍ في التاغات (تاغات عامة وخاصة)

#### ✅ **الحل المطبق:**

##### **التعديل الأول: ملف `config/prompts.json`**
```json
"tags_template": [
  "Give me 40 relevant tags for this book that reflect its content and topic.",
  "",
  "CRITICAL RULES:",
  "- Do NOT mention the book title: {book_name}",
  "- Do NOT mention the author name: {author_name}",
  "- Return ONLY topic-related keywords (e.g., 'personal development', 'success strategies', 'human behavior')",
  "- Each tag should be 1-3 words maximum",
  "- Include general AND specific tags",  // ← إضافة جديدة
  "- Return as a simple comma-separated list",
  "- No numbering, no explanations, just the tags",
  "",
  "Example output: personal growth, leadership skills, power dynamics, social influence, strategic thinking, mindset mastery, habit formation, emotional intelligence",  // ← مثال أكثر تنوعاً
  "",
  "Book: {book_name} by {author_name}"
]
```

**التغييرات:**
- زيادة عدد التاغات من **10 إلى 40**
- إضافة قاعدة جديدة: "Include general AND specific tags"
- مثال أطول يوضح التنوع المطلوب

##### **التعديل الثاني: ملف `src/infrastructure/adapters/youtube_metadata.py`**
```python
# السطر 566 (كان):
return cleaned_tags[:20]  # Max 20 tags (was 10)

# السطر 566 (أصبح):
return cleaned_tags[:40]  # Max 40 AI tags (will be combined with basic tags and trimmed to 500 chars in upload stage)
```

**التغييرات:**
- زيادة الحد الأقصى من **20 إلى 40 تاغاً** للتاغات التي يولدها AI
- تحديث التعليق ليوضح أن المرحلة التالية (upload stage) ستقوم بتقليص التاغات تلقائياً لتناسب حد YouTube البالغ 500 حرف

#### 📊 **النتيجة المتوقعة:**
- **قبل الإصلاح:** ~13 تاغاً فقط
- **بعد الإصلاح:** ~50-60 تاغاً (10-14 تاغات أساسية + 40 تاغاً من AI)
- **عند الرفع:** سيتم تقليصها تلقائياً إلى ~40-50 تاغاً لتناسب حد 500 حرف

---

### 2️⃣ **مشكلة البلاي ليست (Playlist)**

#### 🔴 **الوصف:**
لم يتم إضافة الفيديو إلى أي بلاي ليست عند الرفع، مع أن النظام القديم كان يختار قائمة تشغيل من بين 10 قوائم ثابتة باستخدام Gemini.

#### 🔍 **السبب المحتمل:**
1. الكود **موجود وصحيح** في `youtube_upload.py` (الأسطر 542-554)
2. الكود **موجود وصحيح** في `youtube_metadata.py` (الأسطر 732-740) لتصنيف الكتاب
3. المشكلة قد تكون:
   - فشل Gemini في تصنيف الكتاب بسبب خطأ في API
   - أو لم يتم حفظ الـ playlist في `output.titles.json` بشكل صحيح
   - أو حدث استثناء (exception) خلال عملية الإضافة

#### ✅ **التأكد من الحل:**

الكود الموجود حالياً يجب أن يعمل بشكل صحيح:

##### **في ملف `youtube_metadata.py` (الأسطر 732-743):**
```python
# Add playlist name if not exists - Use Gemini classification
if "playlist" not in updated_titles:
    try:
        from src.infrastructure.adapters.process import _get_book_playlist
        
        # Use model and prompts from outer scope (already loaded)
        # Get classification from Gemini
        playlist = _get_book_playlist(model, book_name, author, prompts)
        updated_titles["playlist"] = playlist
        changed = True
        print(f"✅ Playlist classified by Gemini: {playlist}")
    except Exception as e:
        print(f"❌ Failed to classify playlist: {e}")
        # Use Self-Development as default only if classification fails
        updated_titles["playlist"] = "Self-Development"
        changed = True
```

**ما يحدث:**
1. Gemini يصنف الكتاب إلى واحدة من 10 فئات (Self-Development, Philosophy & Thought, Business & Finance، إلخ)
2. يحفظ اسم الفئة في `output.titles.json`
3. إذا فشل التصنيف، يستخدم "Self-Development" كقيمة افتراضية

##### **في ملف `youtube_upload.py` (الأسطر 542-554):**
```python
# Add to YouTube playlist if playlist name exists (ONLY for main videos, NOT shorts)
if playlist_name and not is_short:
    try:
        if debug:
            print(f"[upload] Adding video to playlist: {playlist_name}")
        playlist_id = _get_or_create_playlist(service, playlist_name, debug=debug)
        if playlist_id:
            _add_video_to_playlist(service, video_id, playlist_id, debug=debug)
            if debug:
                print(f"[upload] ✅ Video added to playlist: {playlist_name}")
    except Exception as pl_err:
        if debug:
            print(f"[upload] playlist error: {pl_err}")
```

**ما يحدث:**
1. يقرأ اسم البلاي ليست من `output.titles.json`
2. يبحث عن البلاي ليست في قناة YouTube
3. إذا لم تكن موجودة، يقوم بإنشائها تلقائياً
4. يضيف الفيديو إلى البلاي ليست

#### 🔧 **خطوات التحقق للتشغيل القادم:**
1. افتح ملف `pipeline.log` في مجلد الـ run
2. ابحث عن السطر: `"✅ Playlist classified by Gemini: [اسم الفئة]"`
3. ابحث عن السطر: `"[upload] Adding video to playlist: [اسم الفئة]"`
4. إذا رأيت خطأ، أرسله لي لتحليله

#### 📋 **القوائم المتاحة:**
1. Self-Development
2. Philosophy & Thought
3. Business & Finance
4. Psychology
5. Literary Novels
6. Spirituality
7. History & Biographies
8. Science & Knowledge
9. Culture & Society
10. Quotes & Reflections

---

### 3️⃣ **مشكلة رفع الشورت (Short Upload)**

#### 🔴 **الوصف:**
فشل رفع فيديو الشورت (60 ثانية) لآخر كتاب، مما أدى إلى عدم اكتمال المعالجة.

#### 🔍 **الأسباب المحتملة:**

##### **السبب 1: فشل توليد الفيديو**
قد يكون ملف `short_final.mp4` لم يتم إنشاؤه بنجاح بسبب:
- فشل في TTS (OpenAI voice API)
- فشل في تحميل الفيديوهات من Pexels
- خطأ في FFmpeg أثناء دمج الفيديوهات والنصوص

##### **السبب 2: فشل الرفع إلى YouTube**
قد يكون الملف موجود لكن الرفع فشل بسبب:
- مشكلة في YouTube API (quota exceeded)
- فشل في المصادقة (authentication)
- خطأ في metadata الخاصة بالشورت

#### ✅ **الحل الموجود في الكود:**

الكود الحالي يحتوي على آليات للتعامل مع هذه المشكلة:

##### **في ملف `run_pipeline.py` (الأسطر 1506-1686):**

```python
# 11) Generate YouTube Short
console.rule("[bold]11) Generate YouTube Short")

# Check if stage already completed (or needs retry)
if not _should_retry_stage(d["root"], "short", failed_stage):
    console.print("[green]✓ Short generation stage already completed (skipping)[/green]")
    short_path = d["root"] / "short_final.mp4"
else:
    _stdout = sys.stdout
    short_path = None
    with combined_log.open("a", encoding="utf-8") as lf:
        sys.stdout = TeeWriter(_stdout, lf)
        print("\n\n==============================================")
        print(f"[Stage] SHORT GENERATION @ {datetime.now().isoformat(timespec='seconds')}")
        print("==============================================")
        print(f"\n[short] Generating 60s vertical video...")
        t0 = time.time()
        try:
            short_path = generate_short(run_dir=d["root"])
        except Exception as e:
            print("Short generation error:", e)
            import traceback
            traceback.print_exc()
            short_path = None
        t1 = time.time()
    sys.stdout = _stdout

    if short_path:
        summary["stages"].append({
            "name": "short_generation",
            "status": "ok",
            "duration_sec": round(t1 - t0, 3),
            "artifact": str(short_path),
        })
        _save_summary(d["root"], summary)
        console.print(f"[green]✅ Short generated: {short_path}[/green]")
    else:
        summary["stages"].append({
            "name": "short_generation",
            "status": "failed",
            "duration_sec": round(t1 - t0, 3),
        })
        _save_summary(d["root"], summary)
        console.print("[yellow]⚠️ Short generation failed (non-critical, continuing)[/yellow]")

# 12) Upload Short to YouTube (if generated successfully)
short_video_id = None
if short_path and short_path.exists():
    console.rule("[bold]12) Upload YouTube Short")

    # Check if stage already completed (or needs retry)
    if not _should_retry_stage(d["root"], "short_upload", failed_stage):
        console.print("[green]✓ Short upload stage already completed (skipping)[/green]")
        # Try to get short_video_id from database or output.titles.json
        try:
            titles_json = d["root"] / "output.titles.json"
            if titles_json.exists():
                tj = json.loads(titles_json.read_text(encoding="utf-8"))
                short_video_id = tj.get("short_youtube_video_id") or tj.get("short_video_id")
        except Exception:
            pass
    else:
        _stdout = sys.stdout

        # [... تحضير metadata للشورت ...]

        # Upload short
        if short_titles_json:
            attempt = 0
            while True:
                attempt += 1
                with combined_log.open("a", encoding="utf-8") as lf:
                    sys.stdout = TeeWriter(_stdout, lf)
                    print("\n\n==============================================")
                    print(f"[Stage] SHORT UPLOAD attempt {attempt} @ {datetime.now().isoformat(timespec='seconds')}")
                    print("==============================================")
                    print(f"\n[short upload] attempt {attempt}...")
                    t0 = time.time()
                    try:
                        short_video_id = upload_main(
                            run_dir=d["root"],
                            titles_json=short_titles_json,
                            secrets_dir=Path("secrets"),
                            privacy_status="public",
                            is_short=True,  # Mark as short to use correct database field
                        )
                    except Exception as e:
                        print("Short upload error:", e)
                        import traceback
                        traceback.print_exc()
                        short_video_id = None
                    t1 = time.time()
                sys.stdout = _stdout

                if short_video_id:
                    summary["stages"].append({
                        "name": "short_upload",
                        "status": "ok",
                        "duration_sec": round(t1 - t0, 3),
                        "artifact": f"https://youtube.com/watch?v={short_video_id}",
                    })
                    _save_summary(d["root"], summary)
                    console.print(f"[green]✅ Short uploaded: https://youtube.com/watch?v={short_video_id}[/green]")

                    # Save short video ID to metadata
                    try:
                        with (d["root"] / "output.titles.json").open("r", encoding="utf-8") as f:
                            metadata_update = json.load(f)
                        metadata_update["short_video_id"] = short_video_id
                        metadata_update["short_video_url"] = f"https://youtube.com/watch?v={short_video_id}"
                        with (d["root"] / "output.titles.json").open("w", encoding="utf-8") as f:
                            json.dump(metadata_update, f, ensure_ascii=False, indent=2)
                    except Exception:
                        pass

                    break

                if attempt >= 3:  # Max 3 attempts for shorts upload
                    console.print("[red]❌ Short upload failed after 3 attempts - CRITICAL STAGE FAILED[/red]")
                    summary["stages"].append({
                        "name": "short_upload",
                        "status": "failed",
                        "duration_sec": round(t1 - t0, 3),
                    })
                    _save_summary(d["root"], summary)
                    # CRITICAL: Raise error to prevent marking book as "done"
                    raise RuntimeError(f"Short upload failed after 3 attempts. Book incomplete - short not uploaded.")

                sleep_s = min(30, 5 * attempt)
                console.print(f"[yellow]Short upload failed (attempt {attempt}). Retrying in {sleep_s}s...[/yellow]")
                time.sleep(sleep_s)
```

**الميزات الموجودة:**
1. ✅ **إعادة المحاولة التلقائية:** يحاول رفع الشورت 3 مرات قبل الفشل
2. ✅ **تسجيل الأخطاء:** يطبع تفاصيل الخطأ الكامل في `pipeline.log`
3. ✅ **منع وضع علامة "done":** إذا فشل رفع الشورت، لا يتم وضع علامة اكتمال على الكتاب
4. ✅ **Resume capability:** يمكن إعادة تشغيل الـ pipeline وسيبدأ من آخر مرحلة فاشلة

#### 🔧 **خطوات التحقق للتشغيل القادم:**

##### **1. التحقق من توليد الشورت:**
```bash
# في PowerShell، تحقق من وجود الملف بعد المرحلة 11
ls "runs\2025-*\short_final.mp4"
```

##### **2. فحص اللوج للأخطاء:**
```bash
# افتح ملف اللوج
notepad "runs\2025-*\pipeline.log"

# ابحث عن:
# - "[Stage] SHORT GENERATION"
# - "[Stage] SHORT UPLOAD"
# - أي أخطاء بعد هذه الأسطر
```

##### **3. إعادة تشغيل Pipeline من آخر مرحلة فاشلة:**
```bash
# استخدم resume command (سيضاف قريباً)
python -m src.presentation.cli.run_resume --run-dir "runs\2025-..."
```

---

## 📝 **ملخص الإصلاحات**

| المشكلة | السبب | الحل | الملفات المعدلة |
|---------|-------|------|------------------|
| **1. التاغات قليلة** | prompts.json يطلب 10 تاغات فقط، والكود يحد بـ 20 | زيادة إلى 40 تاغاً + تحسين التنوع | `config/prompts.json`<br>`src/infrastructure/adapters/youtube_metadata.py` |
| **2. عدم إضافة البلاي ليست** | الكود صحيح، قد يكون خطأ في runtime | لا يوجد تعديل (الكود موجود)، نحتاج فحص اللوج | - (التحقق فقط) |
| **3. فشل رفع الشورت** | فشل في توليد أو رفع الفيديو | الكود يحتوي على retry + error logging | - (التحقق فقط) |

---

## 🚀 **التوصيات للتشغيل القادم**

### 1️⃣ **قبل بدء Pipeline جديد:**
```bash
# تأكد من أن API keys صالحة
python scripts/check_youtube_token.py

# تأكد من Pexels API key (للشورت)
cat secrets/.env | grep PEXELS_API_KEY
```

### 2️⃣ **خلال التشغيل:**
- راقب شاشة الطرفية (terminal) للرسائل الحمراء
- إذا رأيت خطأ في المرحلة 11 أو 12، لا تقلق - سيتم حفظ التقدم

### 3️⃣ **بعد التشغيل:**
```bash
# تحقق من summary.json
cat "runs\2025-*\summary.json"

# تحقق من أن جميع المراحل مكتملة (status: "ok")
# إذا رأيت status: "failed"، افتح pipeline.log لقراءة الخطأ
```

### 4️⃣ **في حالة الفشل:**
```bash
# لا تحذف مجلد الـ run!
# يمكنك إعادة تشغيل Pipeline وسيبدأ من المرحلة الفاشلة تلقائياً

# ملاحظة: خاصية Resume تعمل تلقائياً إذا:
# - نفس الكتاب موجود في database.json بحالة "processing"
# - مجلد الـ run موجود في runs/
# - summary.json يحتوي على status="failed" للمرحلة المعنية
```

---

## 🎯 **النتيجة المتوقعة بعد الإصلاحات**

### ✅ **التاغات:**
- عدد أكبر من التاغات (40-50 تاغاً بدلاً من 13)
- تنوع أفضل (تاغات عامة + تاغات خاصة)
- SEO أفضل لليوتيوب

### ✅ **البلاي ليست:**
- كل فيديو سيتم إضافته تلقائياً إلى فئته الصحيحة
- سهولة في تنظيم القناة
- تجربة أفضل للمشاهدين

### ✅ **الشورت:**
- إعادة محاولة تلقائية عند الفشل
- أخطاء واضحة ومفصلة في اللوج
- إمكانية إكمال المعالجة لاحقاً

---

## 📞 **في حالة استمرار المشاكل**

إذا استمرت أي من المشاكل بعد التعديلات:

1. **احفظ ملف `pipeline.log`** من مجلد الـ run الفاشل
2. **احفظ ملف `summary.json`** من نفس المجلد
3. **احفظ ملف `output.titles.json`** من نفس المجلد
4. **أرسل لي:**
   - الملفات الثلاثة أعلاه
   - وصف موجز للمشكلة (أي مرحلة فشلت؟)
   - رسالة الخطأ إن وجدت

---

**📌 ملاحظة:** هذه الإصلاحات تطبق فوراً ولا تحتاج إعادة تشغيل البرنامج. التشغيل القادم سيستخدم الإعدادات الجديدة تلقائياً.
